package ru.suai;

import org.apache.log4j.*;
import org.jfree.data.xy.XYSeries;
import org.jfree.ui.RefineryUtilities;

import ru.suai.computing.*;
import ru.suai.generators.*;
import ru.suai.monitoring.*;
import ru.suai.view.Visualizator;

import java.io.IOException;
import java.util.HashMap;

/**
 * This class tests and visualize the work of
 * Data smoothing, Predictor on the generated by ArtificialGenerator,
 * DiurnalGenerator data.
 * <p>
 * Also this class shows the work of Predictor on real
 * values of workload from Ganglia monitoring system.
 */
public class Main {
    /**
     * Time period of Ganglia data getting.
     */
    public static final int FETCH_PERIOD = 60000;

    /**
     * Value of plot rendering delay.
     */
    public static final int PLOT_RENDERING_DELAY = 1000;

    /**
     * Count of points on the plot.
     */
    public static final int PLOT_POINTS_COUNT = 10;

    /**
     * Title of generated data line.
     */
    public static final String GENERATED_PLOT_TITLE = "Generated";

    /**
     * Title of smoothed data line.
     */
    public static final String SMOOTHED_PLOT_TITLE = "Smoothed";

    /**
     * Title of predicted data line on the plot.
     */
    public static final String PREDICTED_PLOT_TITLE = "Predicted";

    /**
     * Logger for result check.
     */
    private static final Logger logger = Logger.getLogger(Main.class);

    public static void main(String[] args) {
        //testOnDiurnalGenerator();
        //testOnArtificialGenerator();
        try {
            testOnGangliaMonitoring();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Testing on Ganglia's monitoring data via "diskstat_sda1_writes"
     * metric. Logs in text file.
     *
     * @throws IOException
     */
    private static void testOnGangliaMonitoring() throws IOException {
        int w = 5,
                i = 1,
                qos = 100,
                futurePredicts = 3;

        double p = 0.8, // proportion of maximum values for averaging
                currentSmoothValue = 0,
                currentPredictedValue = 0,
                generatedNumber,
                period = 5.0;
        boolean databaseRequests = false;

        PropertyConfigurator.configure("log4j.properties");

        DataSmoothing ds = new DataSmoothing(w, p);
        Predictor pr = new Predictor(w, w, futurePredicts, qos);

        HashMap<DiurnalGenerator.modulation, Double> modulation = new HashMap<>();
        modulation.put(DiurnalGenerator.modulation.AMPLITUDE, 2.0);
        modulation.put(DiurnalGenerator.modulation.PERIOD, period);
        modulation.put(DiurnalGenerator.modulation.PHASE, 0.0);

        HashMap<DiurnalGenerator.distribution, String> distribution = new HashMap<>();
        distribution.put(DiurnalGenerator.distribution.DISTRIBUTION_TYPE, DiurnalGenerator.POISSON_DISTRIBUTION_TYPE);
        distribution.put(DiurnalGenerator.distribution.SHAPE_TYPE, Predictor.LINEAR_FUNCTION_TYPE);
        distribution.put(DiurnalGenerator.distribution.COEFFICIENT_A, "3.0");
        distribution.put(DiurnalGenerator.distribution.COEFFICIENT_B, "2.0");
        DiurnalGenerator diurnalGenerator = new DiurnalGenerator(modulation, distribution, 10);

        final XYSeries generated = new XYSeries(GENERATED_PLOT_TITLE);
        final XYSeries smoothed = new XYSeries(SMOOTHED_PLOT_TITLE);
        final XYSeries predicted = new XYSeries(PREDICTED_PLOT_TITLE);
        Visualizator chart = new Visualizator(generated, smoothed, predicted);
        UserSimulator userSim;

        RefineryUtilities.centerFrameOnScreen(chart);

        chart.setVisible(true);

        if (databaseRequests) {
            userSim = new UserSimulator("jdbc:mysql://localhost/test", "generator", "asdf1234");
        } else {
            userSim = new UserSimulator("1.txt", "2.txt");
        }

        while (true) {
            int usersCount = (int) diurnalGenerator.getValue(i),
                requestsCount = 500;

            if (databaseRequests) {
                switch ((int) (Math.random() * 3)) {
                    case 0:
                        userSim.generateRequests(usersCount, requestsCount, "SELECT * FROM test");
                        System.out.println("1");
                        break;
                    case 1:
                        userSim.generateRequests(usersCount, requestsCount, "SELECT * FROM test1");
                        System.out.println("2");
                        break;
                    case 2:
                        System.out.println("3");
                        userSim.generateRequests(usersCount, requestsCount, "SELECT * FROM test2");
                        break;
                }
            } else {
                userSim.generateRequests(usersCount, requestsCount, "");
            }

            GangliaRrdMonitor rrdGen = new GangliaRrdMonitor("diskstat_sda1_writes");
            generatedNumber = rrdGen.getNextValue();

            logger.info("Time moment: " + i + ", I/O requests: " + usersCount
                    + ", RRD data: " + generatedNumber);

            ds.addValue(generatedNumber);

            if (i % w == 0) {
                currentSmoothValue = ds.getHybridSmoothValue();
                pr.addValue(currentSmoothValue);
            }

            if (i % w == 0 && i > w * w) {
                currentPredictedValue = pr.getPredict();
                predicted.add((double) i, currentPredictedValue);
                //pr.computeFuturePredictions();
            }

/*            if (i % PLOT_POINTS_COUNT == 0) {
                dataSet.clear();
            }*/


            generated.add((double) i, generatedNumber);
            smoothed.add((double) i, currentSmoothValue);

            // update graphic
            chart.pack();
            ++i;

            try {
                Thread.sleep(FETCH_PERIOD);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Testing work of predictor on generated linear / degree/ exponential data.
     * Visualization shows plot with generated, smoothed and predicted data.
     */
    public static void testOnArtificialGenerator() {
        int w = 25,
                i = 1,
                qos = 100,
                randomness = 450,
                futurePredicts = 3,
                pointsCount = 1000;

        double p = 0.65, // proportion of maximum values for averaging
                currentSmoothValue = 0,
                currentPredictedValue,
                generatedNumber,
                a = 4,
                b = 6;
        String functionType = Predictor.LINEAR_FUNCTION_TYPE;

        DataSmoothing ds = new DataSmoothing(w, p);
        Predictor pr = new Predictor(w, w, futurePredicts, qos);

        final XYSeries generated = new XYSeries(GENERATED_PLOT_TITLE);
        final XYSeries smoothed = new XYSeries(SMOOTHED_PLOT_TITLE);
        final XYSeries predicted = new XYSeries(PREDICTED_PLOT_TITLE);

        Visualizator chart = new Visualizator(generated, smoothed, predicted);
        ArtificialGenerator ag = new ArtificialGenerator(a, b, randomness, functionType);

        RefineryUtilities.centerFrameOnScreen(chart);

        chart.setVisible(true);

        for (int j = 1; j < pointsCount; j++) {

            generatedNumber = (double) ag.getValue(i);

            ds.addValue(generatedNumber);

            if (i % w == 0) {
                currentSmoothValue = ds.getHybridSmoothValue();
                pr.addValue(currentSmoothValue);
            }

            if (i % w == 0 && i > w * w) {
                currentPredictedValue = pr.getPredict();
                predicted.add((double) i, currentPredictedValue);
                //pr.computeFuturePredictions();
            }

/*            if (i % PLOT_POINTS_COUNT == 0) {
                dataSet.clear();
            }*/


            generated.add((double) i, generatedNumber);
            smoothed.add((double) i, currentSmoothValue);

            // update graphic
            chart.pack();
            ++i;

/*            try {
                Thread.sleep(PLOT_RENDERING_DELAY);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }*/
        }
    }

    /**
     * It simulates the operation of the predictor with generated
     * diurnal function and shows the results on the plot.
     */
    private static void testOnDiurnalGenerator() {
        int w = 5,
                i = 1,
                qos = 100,
                futurePredicts = 3,
                pointsCount = 100;

        double p = 0.8, // proportion of maximum values for averaging
                currentSmoothValue = 0,
                currentPredictedValue,
                generatedNumber;

        HashMap<DiurnalGenerator.modulation, Double> modulation = new HashMap<>();
        modulation.put(DiurnalGenerator.modulation.AMPLITUDE, 25.0);
        modulation.put(DiurnalGenerator.modulation.PERIOD, 5.0);
        modulation.put(DiurnalGenerator.modulation.PHASE, 0.0);

        HashMap<DiurnalGenerator.distribution, String> distribution = new HashMap<>();
        distribution.put(DiurnalGenerator.distribution.DISTRIBUTION_TYPE, DiurnalGenerator.POISSON_DISTRIBUTION_TYPE);
        distribution.put(DiurnalGenerator.distribution.SHAPE_TYPE, Predictor.DEGREE_FUNCTION_TYPE);
        distribution.put(DiurnalGenerator.distribution.COEFFICIENT_A, "2.1");
        distribution.put(DiurnalGenerator.distribution.COEFFICIENT_B, "1.3");

        DataSmoothing ds = new DataSmoothing(w, p);
        Predictor pr = new Predictor(w, w, futurePredicts, qos);
        DiurnalGenerator diurnalGenerator = new DiurnalGenerator(modulation, distribution, 50);

        final XYSeries generated = new XYSeries(GENERATED_PLOT_TITLE);
        final XYSeries smoothed = new XYSeries(SMOOTHED_PLOT_TITLE);
        final XYSeries predicted = new XYSeries(PREDICTED_PLOT_TITLE);
        Visualizator chart = new Visualizator(generated, smoothed, predicted);

        RefineryUtilities.centerFrameOnScreen(chart);
        chart.setVisible(true);

        for (int j = 1; j < pointsCount; j++) {

            generatedNumber = diurnalGenerator.getValue(i);

            ds.addValue(generatedNumber);

            if (i % w == 0) {
                currentSmoothValue = ds.getHybridSmoothValue();
                pr.addValue(currentSmoothValue);
            }

            if (i % w == 0 && i > w * w) {
                currentPredictedValue = pr.getPredict();
                predicted.add((double) i, currentPredictedValue);
                //pr.computeFuturePredictions();
            }

/*            if (i % PLOT_POINTS_COUNT == 0) {
                dataSet.clear();
            }*/


            generated.add((double) i, generatedNumber);
            smoothed.add((double) i, currentSmoothValue);

            // update graphic
            chart.pack();
            ++i;

/*            try {
                Thread.sleep(PLOT_RENDERING_DELAY);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }*/
        }
    }
}
