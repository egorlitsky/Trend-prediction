package ru.suai;

import org.apache.log4j.*;
import org.jfree.data.xy.XYSeries;

import ru.suai.computing.*;
import ru.suai.generators.*;
import ru.suai.monitoring.*;
import ru.suai.view.Visualizator;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;

/**
 * This class tests and visualize the work of
 * Data smoothing, Predictor on the generated by ArtificialGenerator,
 * DiurnalGenerator data.
 *
 * Also this class shows the work of Predictor on real
 * values of workload from Ganglia monitoring system.
 */
public class Main {
    /**
     * Time period of Ganglia data getting.
     */
    public static final int FETCH_PERIOD = 60000;

    /**
     * Title of generated data line.
     */
    public static final String GENERATED_PLOT_TITLE = "Generated data";

    /**
     * Title of smoothed data line.
     */
    public static final String SMOOTHED_PLOT_TITLE = "Filtered data";

    /**
     * Title of predicted data line on the plot.
     */
    public static final String PREDICTED_PLOT_TITLE = "Trend prediction";

    /**
     * Message for error message box.
     */
    public static final String ARGUMENTS_ERROR_MESSAGE = "Not enough arguments!\nRun the program with single argument Settings file name";

    /**
     * Message for error message box.
     */
    public static final String READ_FILE_EXCEPTION_MESSAGE = "Exception in reading file with program settings.\n";

    /**
     * Logger for result check.
     */
    private static final Logger logger = Logger.getLogger(Main.class);
	
	/**
     * Indicators of QoS statuses for view.
     */
    public static final int ATTENTION_STATUS_INDICATOR = 2;
	
    public static final int QOS_VIOLATED_INDICATOR = 3;

	public static final int QOS_COMPLIED_INDICATOR = 1;
	
    /**
     * Generate or monitor and predict mode.
     */
    private static String programMode;

    /**
     * Type of modeling in the program.
     */
    private static String modelingType;

    /**
     * Window for prediction and data smoothing.
     */
    private static int w;

    /**
     * Value of Qos requirement.
     */
    private static double qos;

    /**
     * Counts of future prediction since current.
     */
    private static int futurePredictsCount;

    /**
     * Proportion of max values in hybrid data smoothing.
     */
    private static double p;

    /**
     * Amplitude value for DiurnalGenerator.
     */
    private static double amplitude;

    /**
     * Period value for DiurnalGenerator.
     */
    public static double period;

    /**
     * Phase value for DiurnalGenerator.
     */
    private static double phase;

    /**
     * Type of distribution in DiurnalGenerator.
     */
    private static String distributionType;

    /**
     * Type of grow function.
     */
    private static String shapeType;

    /**
     * a coefficient in functions.
     */
    private static double a;

    /**
     * b coefficient in functions.
     */
    private static double b;

    /**
     * Value of mean in poisson distribution.
     */
    private static double mean;

    /**
     * Count of requests of single user
     * at MySQL requests of file copying.
     */
    private static int requestsCount;

    /**
     * Value of stochastic in ArtificialGenerator.
     */
    private static int randomness;

    /**
     * Count of point on the plot.
     */
    private static int pointsCount;

    /**
     * Delay in mills after render one point of plot.
     */
    private static long renderingPlotDelay;

    /**
     * Count of showing points on the plot.
     */
    private static int showingPointsCount;

    /**
     * Flag of removing old point if was added new point.
     */
    private static boolean clearPlot;

    /**
     * Name of disk metric for monitoring by Ganglia.
     */
    private static String monitoringMetricName;

    /**
     * Url to MySQL database for UserSimulator.
     */
    private static String databaseUrl;

    /**
     * Username for access to MySQL database.
     */
    private static String databaseUsername;

    /**
     * Password for access to MySQL database.
     */
    private static String databasePassword;

    public static void main(String[] args) throws IOException {
        PropertyConfigurator.configure(Main.class.getClassLoader().getResource("log4j.properties"));
        String settingsFileName = "settings.properties";

		if (args.length != 2) {
            Visualizator.showErrorMessageBox(ARGUMENTS_ERROR_MESSAGE);
            System.exit(1);
        } else {
            settingsFileName = args[0];

            programMode = args[1];

            loadSettings(settingsFileName);

            if (programMode.equals("-generate")) {
                simulateTraffic();
            }

            if (programMode.equals("-monitor") || programMode.equals("-common")) {
                // selecting mode of program
                switch (modelingType) {
                    case "ARTIFICIAL":
                        testOnArtificialGenerator();
                        break;
                    case "DIURNAL":
                        testOnDiurnalGenerator();
                        break;
                    case "GANGLIA":
                        try {
                            testOnGangliaMonitoring();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        break;
                }
            }
        }
    }

    /**
     * This method loads common properties of peogram,
     * parameters for workload generator's,
     * parameters of the view.
     *
     * @param settingsFileName name of properties file
     */
    private static void loadSettings(String settingsFileName) {
        Properties propertyFile = new Properties();
        InputStream input = null;

        try {
            input = new FileInputStream(settingsFileName);

            // load a properties file
            propertyFile.load(input);

            // load common program parameters
            modelingType = propertyFile.getProperty("MODELING_TYPE");
            w = Integer.parseInt(propertyFile.getProperty("PREDICT_WINDOW"));
            qos = Double.parseDouble(propertyFile.getProperty("QOS_REQUIREMENT"));
            futurePredictsCount = Integer.parseInt(propertyFile.getProperty("FUTURE_PREDICTS_COUNT"));
            p = Double.parseDouble(propertyFile.getProperty("PROPORTION_OF_MAX"));

            // load generator's properties
            amplitude = Double.parseDouble(propertyFile.getProperty("SIN_AMPLITUDE"));
            period = Double.parseDouble(propertyFile.getProperty("SIN_PERIOD"));
            phase = Double.parseDouble(propertyFile.getProperty("SIN_PHASE"));
            distributionType = propertyFile.getProperty("DISTRIBUTION_TYPE");
            shapeType = propertyFile.getProperty("SHAPE_TYPE");

            a = Double.parseDouble(propertyFile.getProperty("A_COEFFICIENT"));
            b = Double.parseDouble(propertyFile.getProperty("B_COEFFICIENT"));
            mean = Double.parseDouble(propertyFile.getProperty("MEAN_VALUE"));
            requestsCount = Integer.parseInt(propertyFile.getProperty("REQUESTS_COUNT"));
            randomness = Integer.parseInt(propertyFile.getProperty("RANDOMNESS"));

            // load database settings
            databaseUrl = propertyFile.getProperty("DATABASE_URL");
            databaseUsername = propertyFile.getProperty("DATABASE_USERNAME");
            databasePassword = propertyFile.getProperty("DATABASE_PASSWORD");

            // load view properties
            pointsCount = Integer.parseInt(propertyFile.getProperty("POINTS_COUNT"));
            showingPointsCount = Integer.parseInt(propertyFile.getProperty("SHOWING_POINTS_COUNT"));
            renderingPlotDelay = Long.valueOf(propertyFile.getProperty("RENDERING_DELAY"));
            clearPlot = Boolean.valueOf(propertyFile.getProperty("CLEAR_PLOT"));

            // Ganglia and UserImitator Settings
            monitoringMetricName = propertyFile.getProperty("MONITORING_METRIC_NAME");
        } catch (IOException ex) {
            logger.info(READ_FILE_EXCEPTION_MESSAGE + ex.getMessage());
            Visualizator.showErrorMessageBox(READ_FILE_EXCEPTION_MESSAGE);
            System.exit(1);
        } finally {
            if (input != null) {
                try {
                    input.close();
                } catch (IOException e) {
                    logger.info(READ_FILE_EXCEPTION_MESSAGE + e.getMessage());
                    Visualizator.showErrorMessageBox(READ_FILE_EXCEPTION_MESSAGE);
                    System.exit(1);
                }
            }
        }
    }

    private static void simulateTraffic() throws IOException {
        int i = 1;

        HashMap<DiurnalGenerator.modulation, Double> modulation = new HashMap<>();
        modulation.put(DiurnalGenerator.modulation.AMPLITUDE, amplitude);
        modulation.put(DiurnalGenerator.modulation.PERIOD, period);
        modulation.put(DiurnalGenerator.modulation.PHASE, phase);

        HashMap<DiurnalGenerator.distribution, String> distribution = new HashMap<>();
        distribution.put(DiurnalGenerator.distribution.DISTRIBUTION_TYPE, distributionType);
        distribution.put(DiurnalGenerator.distribution.SHAPE_TYPE, shapeType);
        distribution.put(DiurnalGenerator.distribution.COEFFICIENT_A, String.valueOf(a));
        distribution.put(DiurnalGenerator.distribution.COEFFICIENT_B, String.valueOf(b));

        DiurnalGenerator diurnalGenerator = new DiurnalGenerator(modulation, distribution, mean);
        UserSimulator userSim = new UserSimulator(databaseUrl, databaseUsername, databasePassword);

        while (true) {
            int usersCount = (int) diurnalGenerator.getValue(i);

            userSim.generateRequests(usersCount, requestsCount);

            // logging
            logger.info("Time moment: " + i + ", Generated I/O requests count: " + usersCount);

            ++i;

            try {
                Thread.sleep(FETCH_PERIOD);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Testing on Ganglia's monitoring data via "diskstat_sda1_writes"
     * metric. Logs in text file.
     *
     * @throws IOException
     */
    private static void testOnGangliaMonitoring() throws IOException {
        double currentSmoothValue = 0,
                generatedNumber;
        int i = 1, k, lastPredictionIndex = 0;

        DataSmoothing ds = new DataSmoothing((int)period, p);
        Predictor pr = new Predictor((int)period, (int)period, futurePredictsCount, qos);

        // initialize the view
        final XYSeries generated = new XYSeries(GENERATED_PLOT_TITLE);
        final XYSeries smoothed = new XYSeries(SMOOTHED_PLOT_TITLE);
        final XYSeries predicted = new XYSeries(PREDICTED_PLOT_TITLE);
        Visualizator view = new Visualizator(generated, smoothed, predicted);
        view.setQosOnPlot(qos);

        ArrayList<Double> temp = new ArrayList<>();

        DiurnalGenerator diurnalGenerator = null;
        UserSimulator userSim = null;
        int usersCount;

        if(programMode.equals("-common")) {
            HashMap<DiurnalGenerator.modulation, Double> modulation = new HashMap<>();
            modulation.put(DiurnalGenerator.modulation.AMPLITUDE, amplitude);
            modulation.put(DiurnalGenerator.modulation.PERIOD, period);
            modulation.put(DiurnalGenerator.modulation.PHASE, phase);

            HashMap<DiurnalGenerator.distribution, String> distribution = new HashMap<>();
            distribution.put(DiurnalGenerator.distribution.DISTRIBUTION_TYPE, distributionType);
            distribution.put(DiurnalGenerator.distribution.SHAPE_TYPE, shapeType);
            distribution.put(DiurnalGenerator.distribution.COEFFICIENT_A, String.valueOf(a));
            distribution.put(DiurnalGenerator.distribution.COEFFICIENT_B, String.valueOf(b));

            diurnalGenerator = new DiurnalGenerator(modulation, distribution, mean);
            userSim = new UserSimulator(databaseUrl, databaseUsername, databasePassword);
        }

        boolean critical = false;

        // main loop
        while (true) {
            if (programMode.equals("-common") && diurnalGenerator != null) {
                usersCount = (int) diurnalGenerator.getValue(i);

                userSim.generateRequests(usersCount, requestsCount);

                // logging
                logger.info("Time moment: " + i + ", Generated I/O requests count: " + usersCount);
            }

            GangliaRrdMonitor rrdGen = new GangliaRrdMonitor(monitoringMetricName);
            generatedNumber = rrdGen.getNextValue();

            // logging
            logger.info("Time moment: " + i + ", RRD data: " + generatedNumber);
            temp.add(generatedNumber);

            int violatedCount = 0;
            for (Double aTemp : temp) {
                if (aTemp > qos)
                    violatedCount++;
            }

            if (((double)violatedCount / period) >= p) {
                view.setAlertState(QOS_VIOLATED_INDICATOR, "");
                System.out.println("FACT:" + (i - (int)period));
            } else {
                if (!critical)
                    view.setAlertState(QOS_COMPLIED_INDICATOR, "");
            }

            ds.addValue(generatedNumber);

            if (i % (int)period == 0) {
                currentSmoothValue = ds.getHybridSmoothValue();
                pr.addValue(currentSmoothValue);

                temp.clear();
            }

            if (i % (int)period == 0 && i > (int)period * (int)period) {
                pr.getPredict();
                pr.computeFuturePredictions();
                ArrayList<Double> predictions = pr.getFuturePredictions();

                k = 1;
                if (lastPredictionIndex > 1) {
                    for (int l = 1; l <= futurePredictsCount; l++) {
                        predicted.remove(lastPredictionIndex - l);
                    }

                    for (int l = 1; l <= futurePredictsCount; l++) {
                        lastPredictionIndex--;
                    }
                }

                for (Object prediction : predictions) {
                    predicted.add((double) (i + k * ((int) period / 2) + 1), (Double) prediction);
                    lastPredictionIndex++;
                    ++k;
                }

                if (pr.isQosViolated() && !critical) {
                    view.setAlertState(ATTENTION_STATUS_INDICATOR, " at " + pr.getQosViolatedTime() + "hour!");
                    critical = true;
                }
            }

            // clearing old points from plot
            if (clearPlot && i > showingPointsCount) {
                generated.remove(0);

                if(i > (int)period) {
                    smoothed.remove(0);
                }

                if (i % (int)period == 0 && i > (int)period * (int)period) {
                    if (predicted.getItems().size() > showingPointsCount / (int)period + futurePredictsCount) {
                        lastPredictionIndex--;

                        predicted.remove(0);
                    }
                }
            }

            generated.add((double) i, generatedNumber);

            if(currentSmoothValue != 0) {
                smoothed.add((double) i - (int)period + 1, currentSmoothValue);
            }

            ++i;

            try {
                Thread.sleep(FETCH_PERIOD);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Testing work of predictor on generated linear / degree/ exponential data.
     * Visualization shows plot with generated, smoothed and predicted data.
     */
    public static void testOnArtificialGenerator() throws IOException {
        int i = 1, k, lastPredictionIndex = 0;
        double currentSmoothValue = 0,
                generatedNumber;

        DataSmoothing ds = new DataSmoothing(w, p);
        Predictor pr = new Predictor(w, w, futurePredictsCount, qos);
        ArrayList<Double> temp = new ArrayList<>();

        final XYSeries generated = new XYSeries(GENERATED_PLOT_TITLE);
        final XYSeries smoothed = new XYSeries(SMOOTHED_PLOT_TITLE);
        final XYSeries predicted = new XYSeries(PREDICTED_PLOT_TITLE);

        Visualizator view = new Visualizator(generated, smoothed, predicted);
        view.setQosOnPlot(qos);

        ArtificialGenerator ag = new ArtificialGenerator(a, b, randomness, shapeType);

        boolean critical = false;

        for (int j = 1; j < pointsCount; j++) {
            generatedNumber = ag.getValue(i);

            temp.add(generatedNumber);

            int violatedCount = 0;
            for (Double aTemp : temp) {
                if (aTemp > qos)
                    violatedCount++;
            }

            if (((double)violatedCount / w) >= p) {
                view.setAlertState(QOS_VIOLATED_INDICATOR, "");
                System.out.println("FACT:" + (i - (int)w));
            } else {
                if (!critical)
                    view.setAlertState(QOS_COMPLIED_INDICATOR, "");
            }

            ds.addValue(generatedNumber);

            if (i % w  == 0) {
                currentSmoothValue = ds.getHybridSmoothValue();
                pr.addValue(currentSmoothValue);

                temp.clear();
            }

            if (i % w == 0 && i > w * w) {
                pr.getPredict();
                pr.computeFuturePredictions();
                ArrayList<Double> predictions = pr.getFuturePredictions();

                k = 1;
                if (lastPredictionIndex > 1) {
                    for (int l = 1; l <= futurePredictsCount; l++) {
                        predicted.remove(lastPredictionIndex - l);
                    }

                    for (int l = 1; l <= futurePredictsCount; l++) {
                        lastPredictionIndex--;
                    }
                }

                for (Object prediction : predictions) {
                    predicted.add((double) (i + k * (w / 2) + 1), (Double) prediction);
                    lastPredictionIndex++;
                    ++k;
                }

                if (pr.isQosViolated() && !critical) {
                    view.setAlertState(ATTENTION_STATUS_INDICATOR, " at " + pr.getQosViolatedTime() + "hour!");
                    critical = true;
                }
            }

            if (clearPlot && i > showingPointsCount) {
                generated.remove(0);

                if(i > w) {
                    smoothed.remove(0);
                }

                if (i % w == 0 && i > w * w) {
                    if (predicted.getItems().size() > showingPointsCount / w)
                        predicted.remove(0);
                }
            }

            generated.add((double) i, generatedNumber);

            if(currentSmoothValue != 0) {
                smoothed.add((double) i - w + 1, currentSmoothValue);
            }

            ++i;

            try {
                Thread.sleep(renderingPlotDelay);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * It simulates the operation of the predictor with generated
     * diurnal function and shows the results on the plot.
     */
    private static void testOnDiurnalGenerator() throws IOException {
        int i = 1, k, lastPredictionIndex = 0;
        double currentSmoothValue = 0,
                generatedNumber;

        HashMap<DiurnalGenerator.modulation, Double> modulation = new HashMap<>();
        modulation.put(DiurnalGenerator.modulation.AMPLITUDE, amplitude);
        modulation.put(DiurnalGenerator.modulation.PERIOD, period);
        modulation.put(DiurnalGenerator.modulation.PHASE, phase);

        HashMap<DiurnalGenerator.distribution, String> distribution = new HashMap<>();
        distribution.put(DiurnalGenerator.distribution.DISTRIBUTION_TYPE, distributionType);
        distribution.put(DiurnalGenerator.distribution.SHAPE_TYPE, shapeType);
        distribution.put(DiurnalGenerator.distribution.COEFFICIENT_A, String.valueOf(a));
        distribution.put(DiurnalGenerator.distribution.COEFFICIENT_B, String.valueOf(b));

        DataSmoothing ds = new DataSmoothing((int)period, p);
        Predictor pr = new Predictor((int)period, (int)period, futurePredictsCount, qos);
        DiurnalGenerator diurnalGenerator = new DiurnalGenerator(modulation, distribution, mean);

        ArrayList<Double> temp = new ArrayList<>();
        final XYSeries generated = new XYSeries(GENERATED_PLOT_TITLE);
        final XYSeries smoothed = new XYSeries(SMOOTHED_PLOT_TITLE);
        final XYSeries predicted = new XYSeries(PREDICTED_PLOT_TITLE);
        Visualizator view = new Visualizator(generated, smoothed, predicted);
        view.setQosOnPlot(qos);

        boolean critical = false;

        for (int j = 1; j < pointsCount; j++) {
            generatedNumber = diurnalGenerator.getValue(i);

            temp.add(generatedNumber);

            int violatedCount = 0;
            for (Double aTemp : temp) {
                if (aTemp > qos)
                    violatedCount++;
            }

            if (((double)violatedCount / period) >= p) {
                view.setAlertState(QOS_VIOLATED_INDICATOR, "");
                System.out.println("FACT:" + (i - (int)period));
            } else {
                if (!critical)
                    view.setAlertState(QOS_COMPLIED_INDICATOR, "");
            }

            ds.addValue(generatedNumber);

            if (i % (int)period  == 0) {
                currentSmoothValue = ds.getHybridSmoothValue();
                pr.addValue(currentSmoothValue);

                temp.clear();
            }

            if (i % (int)period == 0 && i > (int)period * (int)period) {
                pr.getPredict();
                pr.computeFuturePredictions();
                ArrayList<Double> predictions = pr.getFuturePredictions();

                k = 1;
                if (lastPredictionIndex > 1) {
                    for (int l = 1; l <= futurePredictsCount; l++) {
                        predicted.remove(lastPredictionIndex - l);
                    }

                    for (int l = 1; l <= futurePredictsCount; l++) {
                        lastPredictionIndex--;
                    }
                }

                for (Object prediction : predictions) {
                    predicted.add((double) (i + k * ((int) period / 2) + 1), (Double) prediction);
                    lastPredictionIndex++;
                    ++k;
                }

                if (pr.isQosViolated() && !critical) {
                    view.setAlertState(ATTENTION_STATUS_INDICATOR, " at " + pr.getQosViolatedTime() + "hour!");
                    critical = true;
                }
            }

            if (clearPlot && i > showingPointsCount) {
                generated.remove(0);

                if(i > (int)period) {
                    smoothed.remove(0);
                }

                if (i % (int)period == 0 && i > (int)period * (int)period) {
                    if (predicted.getItems().size() > showingPointsCount / (int)period + futurePredictsCount) {
                        lastPredictionIndex--;

                        predicted.remove(0);
                    }
                }
            }

            generated.add((double) i, generatedNumber);

            if(currentSmoothValue != 0) {
                smoothed.add((double) i - (int)period + 1, currentSmoothValue);
            }

            ++i;

            try {
                Thread.sleep(renderingPlotDelay);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}



